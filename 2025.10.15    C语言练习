#include <stdio.h>
//计算调和级数的和
int main() {
    int n, i;
    int a = 1;
    float sum = 0.0;
    while (a == 1) {
    printf("输入n的值：");
    scanf_s("%d", &n);
    for (i = 1;i <= n;i++) {
        sum += 1.0 / i;
    }
    printf("前%d项的和是：%4f\n", n, sum);
    printf("还要继续吗，继续请输入1，否则输入0");
    scanf_s("%d", &a);
    }
    printf("谢谢您的使用！");
    return 0;
}



//遍历1到n的所有偶数
int main() {
    int i=0;
    int n;
    int sum = 0;
    printf("请输入n的值：");
    scanf_s("%d", &n);
    for (i = 2;i <= n;i+=2) {
        printf("%d  ", i);
    }



//更复杂的筛选数字方式
int main() {
    int i, n;
    printf("请输入一个数字：");
    scanf_s("%d", &n);
    for (i = 1;i <= n;i++) {
        if (i % 3 == 0 || i % 7 == 0)
            printf("%d ", i);
    }



//斐波那契数列
    int a, b;
    int n,c,i;
    a = b = 1;
    printf("请输入项数：");
    scanf_s("%d", &n);
    printf("前%d项斐波那契数列为：", n);
    if (n >= 1)
        printf("%d  ", a);
    if (n >= 2)
        printf("%d  ", b);
        for (i = 1;i <= n;i++) {
            c = a + b;
            printf("%d  ",c);
            a = b;
            b = c;
           
        }



//斐波那契数列2:改良了整数溢出问题，同时增加了每5项换行的操作
    long long a = 1, b = 1;  // 用long long存储，范围更大
    long long c;             // 中间变量也需用long long
    int n, i;
    printf("请输入一个数字：");
    scanf_s("%d", &n);
    printf("前%d项斐波那契数列为：\n", n);

    if (n >= 1) {
        printf("%lld  ", a);  // 格式符用%lld匹配long long
    }
    if (n >= 2) {
        printf("%lld  ", b);
    }
    // 从第3项开始计算，直到第n项
    for (i = 3; i <= n; i++) {
        c = a + b;
        printf("%lld  ", c);
        a = b;
        b = c;
        // 每输出5项换行，避免一行太长
        if (i % 5 == 0) {
            printf("\n");
        }
    }




    //求平均值，必须转变思维，我们不能要求让计算机具有人类的思维，即先求和，再求值
    int n,i;
    double num;
    double sum = 0;
    printf("你要输入几个数：");
    scanf_s("%d", &n);
        for (i = 1;i <= n;i++) {
            printf("请输入第%d个数", i);
            scanf_s("%lf", &num);
            sum += num;
    }
        printf("这%d个数的平均数为%lf", n, sum / n);



 
  //打印99乘法表
  int i, j;
  for (i = 1; i <= 9; i++) {
      for (j = 1; j <= i; j++) {
          printf("%d×%d=%d  ", j,i, j * i);
      }
      printf("\n");
  }




//计算sum =a+aa+aaa+aaaa+aaaaa+.......
int main() {
    int a, n,i;
    int term = 0;
    int sum = 0;
    printf("请输入a和n的值： ");
    scanf_s("%d%d", &a, &n);
    for (i = 1;i <= n;i++) {
        term = term * 10 + a;
        sum += term;
    }
    printf("%d", sum);



//关于函数的调用
void calculateArea(double r) {
    double s = 3.14 * r * r;
    printf("圆的面积是：%lf", s);
}
int main() {
    double a;
    printf("请输入圆的半径： ");
    scanf_s("%lf", &a);
    calculateArea(a);




#阶乘（利用递归算法）
int factorial(int n) {
    if (n == 0) 
        return 1;
    
    else 

        return n * factorial(n - 1);   
}
int main() {
    int num = 5;
    printf("%d的阶乘是：%d\n", num, factorial(num));




//寻找数组中的最值
	int lis[5];
	int i, max, min;
	printf("请输入%d个整数：", 5);
	for (i = 0;i <5 ;i++) {
		scanf_s("%d",&lis[i]);
	}
	max = lis[0];
	min = lis[0];
	for (i = 1;i < 5;i++) {
		if (lis[i] > max)
			max = lis[i];
		if (lis[i] < min)
			min = lis[i];
	}
	printf("数组的最大值：%d\n数组的最小值：%d\n", max, min);





//生成一个1-100之间的随机数
#include<stdio.h>
int main(){
	int num = rand() % 100 + 1;
	printf("这次生成了一个1-100的随机数：%d", num);
	return 0;
}




//给一个数开平方（利用sqrt（））
#include <stdio.h>
#include <math.h>  // 别忘了这个,引入新的头文件

int main() {
    double num = 25.0;  // 要开平方的数
    double result = sqrt(num);  // 算平方根

    printf("%lf的平方根是%lf\n", num, result);  // 输出：25.000000的平方根是5.000000
    return 0;
}




//fabs() 函数就像一个 “去符号神器”，专门用来求浮点数的绝对值—— 不管这个数是正数、负数，它都能把前面的 “-” 去掉，只留下数值大小。
#include <stdio.h>
#include <math.h>

int main() {
    double yesterday = -2.5;  // 昨天温度
    double today = 3.0;       // 今天温度
    double diff = fabs(today - yesterday);  // 温差（用绝对值确保结果为正）

    printf("两天的温差是：%lf℃\n", diff);  // 计算：3.0 - (-2.5) = 5.5，绝对值还是5.5 → 输出5.500000℃
    return 0;
}

注意！！！！！！
fabs() 处理浮点数（带小数点的数，比如 3.14、-5.2）；
abs() 处理整数（不带小数点的数，比如 5、-3），它在 <stdlib.h> 头文件里。




//pow( )库函数的使用
#include <stdio.h>
#include <math.h>

int main() {
    double result1 = pow(2, 5);  // 2^5
    double result2 = pow(3, 2);  // 3^2（平方）
    
    printf("2的5次方 = %.0lf\n", result1);  // 输出：32（%.0lf表示不显示小数）
    printf("3的平方 = %.0lf\n", result2);    // 输出：9
    return 0;
}



// auto变量
实际上局部变量都是auto变量
//register变量
将变量放在了寄存器上，使其访问的速度更快


//数组
//一维数组 
int arr[3] = {10, 20, 30};
printf("%d\n", arr[0]);  // 输出第一个元素：10
arr[1] = 200;            // 修改第二个元素为200
printf("%d\n", arr[1]);  // 输出修改后的值：200

//二维数组
int matrix[2][3] = {
    {1, 2, 3},  // 第0行
    {4, 5, 6}   // 第1行
};
printf("%d\n", matrix[0][2]);  // 输出第0行第2列元素：3
matrix[1][1] = 50;             // 修改第1行第1列元素为50

//计算数组的和
#include <stdio.h>
int sum_shuzu(int nums[], int len) {
	int sum = 0;
	for (int i = 0;i < len;i++) {
	sum += nums[i];
    }
	return sum;
}
int main() {
	int s[] = { 1, 2, 3, 4, 5 };
	int len = sizeof(s) / sizeof(s[0]);
	printf("数组的和为：%d",sum_shuzu(s, len));
	return 0;
}

//在 C 语言中，“数组也是指针” 的说法并不完全准确，更严谨的表述是：数组名在大多数语境下会隐式转换为指向数组首元素的指针。
这种 “退化”（decay）特性使得数组和指针在很多场景下表现出相似的行为，从而造成 “数组就是指针” 的误解。
C 语言标准规定：在大多数表达式中，数组名会自动转换为指向其首元素的指针（即 &数组名[0]）。这种转换是编译器自动完成的，无需显式操作。

C 语言中，指针 + 整数 n 的结果是：指针指向 “当前元素往后第 n 个元素” 的地址，偏移的字节数 = n × 单个元素的字节数（由元素类型决定）。
对 int 类型数组来说，单个元素占 4 字节（假设系统中 int 为 4 字节），因此：arr + 1 会从 arr[0] 的地址向后偏移 1 × 4 = 4 字节，正好指向 arr[1] 的地址。
#include <stdio.h>
int main() {
	int a[][4] = { 2,3,4 };
	printf("%d", *(*a+1));
	return 0;
}

//至此，我们搞清楚了数组的指针性质


//如何声明一个新的类型名
typedef 原类型 新类型名;
typedef int Integer;         // Integer 等价于 int
typedef float FloatNumber;   // FloatNumber 等价于 float

int main() {
    Integer a = 100;         // 等价于 int a = 100;
    FloatNumber b = 3.14f;   // 等价于 float b = 3.14f;
    printf("a = %d, b = %f\n", a, b);  // 输出：a = 100, b = 3.140000
    return 0;
//为指针类型创建别名
typedef int* IntPtr;         // IntPtr 等价于 int*（指向 int 的指针）
typedef char**CharDoublePtr; // CharDoublePtr 等价于 char**（指向 char 指针的指针）

int main() {
    int x = 20;
    IntPtr p = &x;           // 等价于 int* p = &x;
    printf("*p = %d\n", *p); // 输出：*p = 20

    char c = 'A';
    char* pc = &c;
    CharDoublePtr ppc = &pc; // 等价于 char**ppc = &pc;
    printf("**ppc = %c\n", **ppc); // 输出：**ppc = A
    return 0;
}

// 为结构体创建别名
typedef struct {
    char name[20];
    int age;
} Student; // Student 等价于 struct 匿名结构体



//结构体初步应用                                              
typedef struct Student {
    char name[20];  // 姓名（字符串，数组）
    int age;        // 年龄（整数）
    float score;    // 成绩（浮点数）
} Stu;

int main() {
    Stu s;  // 声明结构体变量

    // 1. 输入姓名（字符串，数组名是地址，无需&）
    printf("请输入姓名：");
    // %19s 限制输入长度为19（留1个字节给字符串结束符'\0'，避免数组溢出）
    scanf("%19s", s.name);

    // 2. 输入年龄（整数，需要&取地址）
    printf("请输入年龄：");
    scanf("%d", &s.age);

    // 3. 输入成绩（浮点数，需要&取地址）
    printf("请输入成绩：");
    scanf("%f", &s.score);

    // 验证输入结果
    printf("\n输入的信息如下：\n");
    printf("姓名：%s\n", s.name);
    printf("年龄：%d\n", s.age);
    printf("成绩：%.1f\n", s.score);

    return 0;
}




以下是 C 语言**常用占位符速查表**，按数据类型分类整理，包含对应类型、说明及示例，方便日常开发查阅：

| 分类         | 占位符          | 对应数据类型                  | 说明（`printf` 中）                                                                 | 示例（输出结果）                          |
|--------------|-----------------|-------------------------------|--------------------------------------------------------------------------------------|-------------------------------------------|
| **整数**     | `%d`            | `int`（有符号整数）           | 十进制输出有符号整数（支持负数、0）                                                  | `printf("%d", -123);` → `-123`            |
|              | `%u`            | `unsigned int`（无符号整数）  | 十进制输出无符号整数（仅非负数）                                                     | `printf("%u", 255);` → `255`              |
|              | `%o`            | `unsigned int`                | 八进制输出（无符号，无前缀 `0`）                                                     | `printf("%o", 8);` → `10`                 |
|              | `%x`            | `unsigned int`                | 十六进制输出（小写 `a-f`，无前缀 `0x`）                                              | `printf("%x", 255);` → `ff`               |
|              | `%X`            | `unsigned int`                | 十六进制输出（大写 `A-F`，无前缀 `0X`）                                              | `printf("%X", 255);` → `FF`               |
| **短整数**   | `%hd`           | `short int`（短有符号）       | 十进制输出短整数                                                                     | `printf("%hd", (short)32767);` → `32767`  |
|              | `%hu`           | `unsigned short`（短无符号）  | 十进制输出无符号短整数                                                               | `printf("%hu", (unsigned short)65535);` → `65535` |
| **长整数**   | `%ld`           | `long int`（长有符号）        | 十进制输出长整数                                                                     | `printf("%ld", 1234567890L);` → `1234567890` |
|              | `%lu`           | `unsigned long`（长无符号）   | 十进制输出无符号长整数                                                               | `printf("%lu", 4294967295UL);` → `4294967295` |
|              | `%lld`          | `long long`（长长有符号）     | 十进制输出更长的整数（C99 支持）                                                     | `printf("%lld", 9223372036854775807LL);` → `9223372036854775807` |
| **浮点数**   | `%f`            | `float` / `double`            | 小数形式输出（默认保留 6 位小数）                                                    | `printf("%f", 3.14);` → `3.140000`        |
|              | `%lf`           | `double`                      | 同 `%f`（`printf` 中可混用，`scanf` 中必须用于 `double`）                            | `printf("%lf", 3.1415926);` → `3.141593`  |
|              | `%e`            | `float` / `double`            | 科学计数法（小写 `e`）                                                               | `printf("%e", 12345.6);` → `1.234560e+04` |
|              | `%E`            | `float` / `double`            | 科学计数法（大写 `E`）                                                               | `printf("%E", 12345.6);` → `1.234560E+04` |
|              | `%g`            | `float` / `double`            | 自动选 `%f` 或 `%e`（去尾零，更简洁）                                                | `printf("%g", 12345.6);` → `12345.6`      |
| **字符/字符串** | `%c`            | `char`（单个字符）            | 输出单个字符                                                                        | `printf("%c", 'A');` → `A`                |
|              | `%s`            | `char*`（字符串，以 `\0` 结尾） | 输出字符串                                                                        | `printf("%s", "Hello");` → `Hello`        |
| **指针**     | `%p`            | `void*`（任意指针）           | 以十六进制输出指针地址（带 `0x` 前缀）                                                | `int a; printf("%p", &a);` → `0x7ffd...`  |
| **特殊**     | `%%`            | 无（输出 `%` 符号）           | 转义输出 `%`（因 `%` 是占位符前缀，需用 `%%` 表示）                                   | `printf("百分比：%%");` → `百分比：%`     |


### 格式修饰符补充（控制输出格式）
| 修饰符       | 作用说明                                                                 | 示例（输出结果）                          |
|--------------|--------------------------------------------------------------------------|-------------------------------------------|
| `%5d`        | 宽度控制：输出至少占 5 个字符，不足左补空格（右对齐）                     | `printf("%5d", 123);` → `  123`（前补2空格） |
| `%-5d`       | 左对齐：输出至少占 5 个字符，不足右补空格                                 | `printf("%-5d", 123);` → `123  `（后补2空格） |
| `%.3d`       | 精度控制（整数）：至少 3 位，不足前补 0                                   | `printf("%.3d", 12);` → `012`             |
| `%.2f`       | 精度控制（浮点数）：保留 2 位小数                                         | `printf("%.2f", 3.1415);` → `3.14`        |
| `%.3s`       | 精度控制（字符串）：只输出前 3 个字符                                     | `printf("%.3s", "Hello");` → `Hel`        |
| `%+d`        | 强制显示正负号（正数显 `+`，负数显 `-`）                                  | `printf("%+d %+d", 10, -20);` → `+10 -20` |


### 注意事项
1. **类型匹配**：占位符必须与变量类型对应（如 `%d` 对应 `int`，`%f` 对应 `float`），否则输出乱码。  
2. **`scanf` 特殊规则**：  
   - 输入 `float` 用 `%f`，输入 `double` 必须用 `%lf`（否则数据错误）；  
   - 输入字符串用 `%s` 时，建议加长度限制（如 `%19s`）避免数组溢出。  
3. **无符号整数**：用 `%u`/`%hu`/`%lu` 输出，若用 `%d` 可能显示负数（因符号位被解析）。  

























