
/*三整数排序*/
#include<stdio.h>
int main(){
	int a,b,c,t;
	scanf("%d%d%d",&a,&b,&c);
	if(a>b){
		t=a;
		a=b;
		b=t;
	}
	if(a>c){
		t=a;
		c=a;
		c=t;
	}
	if(b>c){
		t=b;
		c=b;
		b=c;
	}
	 printf("%d %d %d\n",a,b,c);
	return 0;
}



/*三位数反转*/
#include<stdio.h>
int main(){
	int a,b;
	scanf("%d",&a);
	b=(a%10)*100+(a/10%10)*10+(a/100);
	printf("%03d\n",b);
	
	return 0;
}




/*鸡兔同笼，先输出鸡的数量，再输出兔的数量*/
#include<stdio.h>
int main(){
	int n,m,a,b;/*n是总头数，m是总腿数,a是鸡的数量*/
	scanf("%d %d",&n,&m);
	b=(m-2*n)/2;
	a=n-b;
	if(a<0||b<0||m%2==1){
		printf("此题无解"); 
	}
	else
		printf("%d %d",a,b);
	return 0;
}


//这是一段有疑问的代码（详见p15实验B4）
#include <stdio.h>
int main() {
    int a, b;
    scanf("%d%d", &a, &b);
    printf("a=%d, b=%d\n", a, b);  // 输出结果
    
    return 0;
}


/*判断三角形，直角三角形*/ 
#include <stdio.h>
int main() {
	int a,b,c;
	scanf("%d%d%d",&a,&b,&c);
	if(a+c<=b||a+b<=c||c+b<=a){
		printf("not a triangle");
	}
	else{
			if(a*a==b*b+c*c||c*c==b*b+a*a||b*b==a*a+c*c)
				printf("yes");
			else
				printf("no");
	}

	
	
    return 0;
}


/*判断闰年*/
#include<stdio.h>
int main() {
    int year;
    scanf("%d", &year);
    if ((year % 400 == 0) || (year % 4 == 0 && year % 100 != 0)) {
        printf("yes");
    } else {
        printf("no");
    }
    return 0;
}


一些常见数据类型的范围
int
  int 的最大最小值不固定，核心取决于系统 / 编译器的 int 位数，最常见的是 32 位（当前主流系统默认）。
32 位 int（主流情况）：最大值 2147483647，最小值 -2147483648。
16 位 int（老式系统 / 嵌入式）：最大值 32767，最小值 -32768。
关键说明
int 是 “有符号整数”，用最高位表示符号（0 为正，1 为负），剩余位存储数值。
32 位 int 共 2^32 个取值，范围是 -2^31 到 2^31 - 1（即 -2147483648 到 2147483647）。
无符号 int（unsigned int）无负数，32 位时范围是 0 到 4294967295（2^32 - 1）

double
  double 类型（双精度浮点数）的最大 / 最小值遵循 IEEE 754 标准（几乎所有现代系统都采用），其取值范围由 64 位存储结构（1 位符号位 + 11 位指数位 + 52 位尾数位）决定。
  核心结论
  最大有限值（DBL_MAX）：约 1.7976931348623157e+308（即约 
  1.8E308）。
  最小正值（接近 0 的正数，DBL_MIN）：约 2.2250738585072014e-308（即约 
  2.2E?308）。
  最小负值（最大的负数）：约 -1.7976931348623157e+308（最大有限值的相反数）。


常见运算符的优先级

优先级组	运算符	名称 / 功能	结合性
1	()、[]、->、.	括号、数组下标、指针访问、成员访问	左结合
2	!、++、--、-（负号）	逻辑非、自增、自减、取负	右结合（单目）
3	*、/、%	乘法、除法、取模	左结合
4	+、-	加法、减法	左结合
5	>、<、>=、<=	大于、小于、大于等于、小于等于	左结合
6	==、!=	等于、不等于	左结合
7	&&	逻辑与	左结合
7	||	逻辑或	左结合
8	=、+=、-=、*=、/=、%=	赋值、复合赋值	右结合





// 输入所有形如aabb的四位完全平方数 
//在问题相对复杂的情况下，可使用伪代码，即先输入一些非法语句来启发思路 
#include<stdio.h>
#include<math.h>
int main(){
	for(int a=1;a<=9;a++){
		for(int b=0;b<=9;b++){
			int n=a*1100+b*11;
			int m=floor(sqrt(n));
			if(n==m*m){
				printf("%d",n);
			}			
		}
		
	} 
	return 0;
}
//加入数学知识 可以大量简化代码复杂度 
/*for(int a=2; a<=9; a++){  // a从2到9（确保b=11-a是有效数字）
    int b = 11 - a;
    int n = a*1100 + b*11;
    int m = sqrt(n);  // 因n是正数，可直接用(int)转换，无需floor
    if(m*m == n){
        printf("%d\n", n);
    }
}*/




//while 循环  与  do-while 循环
//猜想：对于一个任意的正整数n,给出以下变换：如果n属于奇数
//则令n=n*3+1,否则n=n/2,经历这样的若干次变换之后，n会变成1 

#include<stdio.h>
int main(){
	int n;
	int count =0;
	scanf("%d",&n);
	while(n>1){
		if(n%2==1){
			n=n*3+1;
		}
		else
		    n=n/2;
		count ++;
		
	}	
	printf("%d\n",count);	
	return 0;
} 




//近似计算
//计算pi/4=1-1/3+1/5-1/7+...,直到最后一项小于1e-6 
#include<stdio.h>
int main(){
	double p =0.0;
	int sign=1;
	for(double i=1.0; ;i=i+2){
		p+=sign/i;
		if((1/i)<1e-6){
			printf("%lf",p*4);
			break;
		}
		sign=-sign;
	}
	return 0;
} 




//输入n,计算S=1!+2!+3!+4!+.....的末六位。 
#include<stdio.h>
int main(){
	int n;
	int sum=1;
	int SUM=1;
	scanf("%d",&n);
	for(int i =1;i<=n;i++){
		for(int j=1;j<=i;j++){
			sum*=j;
		}
		SUM+=sum;
		sum=1;
	}
	printf("%d",SUM%1000000);
	
	
	return 0;
} 
//代码的问题如下：
//变量的定义要遵循就近原则 
/*#include<stdio.h>
int main(){
    int n;
    scanf("%d", &n);
    int sum_total = 0;  
    int factorial = 1;  
    for(int i = 1; i <= n; i++){
        factorial = (factorial * i) % 1000000;
        sum_total = (sum_total + factorial) % 1000000;
    }
    printf("%d\n", sum_total);
    return 0;
}*/



   
//第一次使用文件的简易方式 
//重定向版 
/*#define LOCAL*///只要删除，那么#ifdef LOCAL--#endif之间的语句都不会执行 
#include<stdio.h>
#define INF 10000000
int main(){
	#ifdef LOCAL
	 freopen("input.txt","r",stdin);
	 freopen("output.txt","w",stdout);
	 #endif
	 int x,n=0,min=INF,max=-INF,s=0;
	 while(scanf("%d",&x)==1){
	 	s+=x;
	 	if(x<min)min=x;
	 	if(x>max)max=x;
	 	n++;
	 }
	 printf("%d %d %.3f",min,max,(double)s/n);

	return 0;
} 
//但只会操作文件，任重而道远




//第二次使用文件的简易方式 
//正式版(fopen) 

#include<stdio.h>
#define INF 10000000

int main(){
	FILE *fin,*fout;
	fin = fopen("data.in","rb");
	fout=fopen("data.out","wb");
	
	 int x,n=0,min=INF,max=-INF,s=0;
	 while(fscanf(fin,"%d",&x)==1){
	 	s+=x;
	 	if(x<min)min=x;
	 	if(x>max)max=x;
	 	n++;
	 }
	 fprintf(fout,"%d %d %.3f",min,max,(double)s/n);

	return 0;
	
} 
//与python相比，这确实略显麻烦 
//若想将其改为标准型输入，只需赋值fin=stdin,fout=stdout




//第一次独立写出水仙花数
#include<stdio.h>
int main(){
	for(int i=100;i<=999;i++){
		int a=i/100;
		int b=i%100/10;
		int c= i%10;
		if(i==a*a*a+b*b*b+c*c*c)
		printf("%d\n",i);
	}
	return 0;
} 


//韩信点兵 
#include<stdio.h>
int main(){
	int a,b,c,found=0;
	scanf("%d%d%d",&a,&b,&c);
	for(int i=10;i<=100;i++){
		if(i%3==a&&i%5==b&&i%7==c){
			printf("%d\n",i);
			found=1;
		}
	
		}	
		if(found==0)
			printf("No answer!");
	
	
	return 0;
	
}


//倒三角，由于C语言没有Python的语言特性，所以只能借助循环来完成 
#include<stdio.h>
int main(){
	int n;
	scanf("%d",&n);
	for(int j=0;j<n;j++){
		for(int i=j-1;i>0;i--){
			printf(" ");
		}
		for(int k=1;k<=2*(n-j)-1;k++){
			printf("#");
			
			//TODO
		}
		printf("\n");		
	}
}



//子序列的和 
#include<stdio.h>
int main(){
    int n, m;
    double s; 
    while(scanf("%d%d", &n, &m) == 2 && (n != 0 || m != 0)){
        s = 0;  
        if(n > m){
            int temp = n;
            n = m;
            m = temp;
        }
        for(int i = n; i <= m; i++){
            s += 1.0 / (i * i); 
        }
        printf("%.5f\n", s);
    }
    return 0;
}



//分数化小数 
#include<stdio.h>
int main(){
	int c;
	double a,b;
	while(scanf("%lf%lf%d",&a,&b,&c)==3&&(a!=0||b!=0||c!=0)){
		printf("%.*f\n",c,a/b);
	}
	return 0;
} 



//排序  第一次练习排序题
//在这里首次接触到了不重不漏的概念，有点挑战性！！ 
#include<stdio.h>
#include<time.h>
int main(){
	clock_t start =clock();
	for(int num_1=102;num_1<=329;num_1++){
		int num_2=num_1*2;
		int num_3=num_1*3;
		int a=num_1/100;
		int b=num_1%100/10;
		int c=num_1%10;
		int d=num_2/100;
		int e=num_2%100/10;
		int f=num_2%10;
		int g=num_3/100;
		int h=num_3%100/10;
		int i=num_3%10;
		int digits[10]={0};
		digits[a] = 1;
		digits[b] = 1;
		digits[c] = 1;
	    digits[d] = 1;
		digits[e] = 1;
		digits[f] = 1;
		digits[g] = 1;
		digits[h] = 1;
		digits[i] = 1;
		int valid = 1;
		    for (int i = 1; i <= 9; ++i) {
		        if (digits[i] != 1) {
		                valid = 0;
		                break;
		        }
		    }
		    if (valid) {
		            printf("%d %d %d\n", num_1, num_2, num_3);
		    }
		}
			clock_t end=clock();
		
			printf("TIME is used %.5f\n",(double)(end-start)/CLOCKS_PER_SEC);
	return 0;
} 
//在C语言中，数组是检验不重不漏的有效手段，例如检验1--9数字是否全被使用完毕，只需要一个数组digits 
// digits的作用：
/*它利用数组的索引特性模拟了 “键值对” 的功能：
索引 i（1~9）对应 “数字i”（相当于 “键”）。
数组元素 digits[i] = 1 表示 “数字i出现过”（相当于 “值” 为 “已出现”）。
通过遍历 digits[1]~digits[9]，检查是否全为1，即可判断 1-9 是否恰好各出现一次（无重复、无 0）*/ 
//更聪明的做法
#include<stdio.h>
int check(int a,int digit[]){
	for(int i =0;i<3;i++){
		int b=a%10;
		if(b==0||digit[b])return 0;
		digit[b]=1;
		a=a/10;	
	}	
	return 1;
} 
int main(){
	for(int s=102;s<=333;s++){
		int digit[10]={0};
		if(check(s,digit)&&check(s*2,digit)&&check(s*3,digit))
			printf("%d %d %d\n",s,s*2,s*3);
	}
	return 0;
}



//这个例子可以更好理解浮点数的精度问题 
#include<stdio.h>
int main(){
	double i;
	for(i=0;i!=10;i+=0.1){
		printf("%.1f\n",i);
	}
	return 0; 
	
} 


//数组的逆序输出
#include<stdio.h>	
	int arr[100000000]={};//如果数组特别大，其定义要放在main()函数外面，否则运行不了
int main(){
	int x,n=0;

	while(scanf("%d",&x)==1&&x!=0){
		arr[n++]=x;
	}
	for(int i=n-1;i>=0;i--){
		printf("%d\t",arr[i]);
	}
	
	
	return 0;
} 

注意！！！！
在C语言中，数组不能直接赋值
要从数组a复制元素到数组b中，可以用memcpy(b.a.sizeof(int)*k)
代表了从a中复制了k个元素到b
使用之前需要include<string.h>




/*有 n 盏灯，编号为 1~n，初始状态都是关闭的。第 1 个人把所有灯打开；
第 2 个人按下所有编号为 2 的倍数的开关（这些灯会被关闭）；
第 3 个人按下所有编号为 3 的倍数的开关（此时关着的灯会被打开，开
着的灯会被关闭）；依此类推，第 i 个人按下所有编号为 i 的倍数的开关。
问：有k个人，哪些灯最终是亮着的？*/ 
//编写程序，输入 n,k   输出开着的灯的编号
#include<stdio.h>
int main(){
	int k,n;	
	scanf("%d %d",&n,&k);
	int arr[n]={0}; //也可以使用数组清零技巧
	//memset(arr,o,sizeof(a)) 
	for(int i=1;i<=k;i++){
		for(int j=1;j*i<=n;j++){
		    arr[j*i-1]=!arr[j*i-1];
		}	
	}	
	for(int i=0;i<n;i++){
		if(arr[i])
		printf("%d\t",i+1);
	}
	return 0;
}
补充：j*i也可以用整除思想代替




//蛇形填数（n*n方阵）
#include<stdio.h>
#include<string.h>
#define maxn 20 
int arr[maxn][maxn];
int main(){
	int n,oringin,x,y;
	scanf("%d",&n);
	memset(arr,0,sizeof(arr));
	oringin=arr[x=0][y=n-1]=1;
	while(oringin<n*n){
		while(x+1<n&&!arr[x+1][y])arr[++x][y]=++oringin;
		while(y+1<n&&!arr[x][y+1])arr[x][++y]=++oringin;
		while(x>=1&&!arr[x-1][y])arr[--x][y]=++oringin;
		while(y>=1&&!arr[x][y-1])arr[x][--y]=++oringin;
	}
	for(x=0;x<n;x++){
		for(y=0;y<n;y++)printf("%3d",arr[x][y]);
		printf("\n");
	}
	return 0;
} 





